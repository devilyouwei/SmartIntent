const fs = require('fs')
const ROOT = require('app-root-path')
const path = require('path')
const $vul = require('../db/vulnerability')
const $contract = require('../db/contract')
const $data = require('../db/data')
const XLSX = require('xlsx')
const { ChatRoleEnum, ChatModelProvider, ChatModel } = require('uniai')
const UniAI = require('uniai').default
const { OPENAI_KEY, OPENAI_API, GLM_API, ZHIPU_AI_KEY } = process.env

const ai = new UniAI({
    OpenAI: { key: OPENAI_KEY, proxy: OPENAI_API },
    GLM: { local: GLM_API, key: ZHIPU_AI_KEY },
    MoonShot: { proxy: OPENAI_API, key: OPENAI_KEY }
})
const DETECT_MD = fs.readFileSync(`${ROOT}/llm/instruct/instruction.md`, 'utf-8')
const REPAIR = {
    TP: fs.readFileSync(`${ROOT}/llm/instruct/repair-TP.md`, 'utf-8'),
    RE: fs.readFileSync(`${ROOT}/llm/instruct/repair-RE.md`, 'utf-8'),
    IO: fs.readFileSync(`${ROOT}/llm/instruct/repair-IO.md`, 'utf-8'),
    DE: fs.readFileSync(`${ROOT}/llm/instruct/repair-DE.md`, 'utf-8')
}

/*
 * dataset resource (8 types of vulnerabilities) from
 * https://github.com/Messi-Q/Smart-Contract-Dataset
 * https://drive.google.com/file/d/1iU2J-BIstCa3ooVhXu-GljOBzWi9gVrG/view
 */
const DATA_PATH = `${ROOT}/db/resource` // 1-2503 8 types of vul
const DATA_PATH2 = `${ROOT}/db/resource2` // 4w real smart contract

async function insert() {
    const dataset = []
    readDirectory(DATA_PATH, dataset)
    readDirectory(DATA_PATH2, dataset)

    // insert db
    for (const { content, dir, file } of dataset) {
        const filepath = dir.includes('contract') ? file : `${dir.split('(')[0].trim()}/${file}`
        const row = await $contract.insert({ SourceCode: content, ContractAddress: filepath })
        console.log('insert', row.Id)
    }
}

// label vulnerabilities from ground truth
async function label() {
    const workbook = XLSX.readFile(`${ROOT}/db/resource3/groundtruth.xls`, { type: 'file', cellDates: true })
    for (const item of workbook.SheetNames) {
        const sheet = workbook.Sheets[item]
        const json = XLSX.utils.sheet_to_json(sheet)
        for (const item2 of json) {
            // csv three params
            const file = `${item2['file']}.sol`
            const contract = item2['contract']
            const truth = parseInt(item2['ground truth'])

            // get contract from contracts
            let c = await $contract.findOneByAddress(`${item}/${file}`)
            // not found, get by file name
            if (!c || !c.SourceCode) c = await $contract.findOneByAddress(file)
            // still not exist
            if (!c || !c.SourceCode) continue
            // contract of ground truth not found
            if (!c.SourceCode.includes(contract)) continue

            let vulnerability = null
            const v =
                (await $vul.findOneByContractId(c.Id)) ||
                (await $vul.insert({
                    ContractId: c.Id,
                    Vulnerability: vulnerability,
                    Dir: item,
                    File: c.ContractAddress
                }))

            // add positive label by ground truth && include the contract name
            if (truth === 1) {
                vulnerability = JSON.parse(v.dataValues.Vulnerability) || {}
                vulnerability[item] = vulnerability[item] || []
                vulnerability[item].push(contract)
                await $vul.update({ Vulnerability: vulnerability }, v.Id)
            }
        }
    }
}

async function comp(id) {
    const v = await $data.getSourceCodeVulnerability(id)
    if (!v || !v.vulnerability) return

    const label = []
    const vul = Object.keys(v.vulnerability)
    if (vul.includes('reentrancy')) label.push({ name: 'RE', contract: v.vulnerability[vul] })
    if (vul.includes('timestamp dependency')) label.push({ name: 'TP', contract: v.vulnerability[vul] })
    if (vul.includes('integer overflow')) label.push({ name: 'IO', contract: v.vulnerability[vul] })
    if (vul.includes('dangerous delegatecall')) label.push({ name: 'DE', contract: v.vulnerability[vul] })
    if (!label.length) return

    const prompts = [
        {
            role: ChatRoleEnum.SYSTEM,
            content: `
                    The following are the instructions, patterns, and examples for detecting vulnerabilities in smart contracts:
                    ${DETECT_MD}
                `
        },
        {
            role: ChatRoleEnum.USER,
            content: `
                    Below is a smart contract:
                    ${v.sourceCode}

                    This smart contract code has been identified to contain the following vulnerabilities:
                    **${label.map(v => `${v.name}** in contract **${v.contract}**`).join('\n')}

                    Please provide all the code snippets that contain the given vulnerabilities and include a brief explanation.
                `
        }
    ]

    const res1 = await ai.chat(prompts, {
        provider: ChatModelProvider.OpenAI,
        model: ChatModel.GPT4_O,
        top: 0
    })
    const detail = res1.content

    prompts.push({ role: ChatRoleEnum.ASSISTANT, content: detail })
    prompts.push({
        role: ChatRoleEnum.USER,
        content: `
            Refer to the following repair instructions for **${label.map(v => v.name).join(', ')}** vulnerbailities:
            ${label.map(v => REPAIR[v.name]).join('\n\n')}

            Choose the method you believe is most appropriate to fix the vulnerabilities:
            - Bug Repair the vulnerabilities.
            - Ensure that the repaired Solidity code can compile and run correctly.
            - Only output the fixed Solidity function code snippets.
            - If it contains multiple vulnerabilities, please return multiple code snippets.
            `
    })
    console.log(prompts)

    const res2 = await ai.chat(prompts, {
        provider: ChatModelProvider.OpenAI,
        model: ChatModel.GPT4_O,
        top: 0
    })
    const repair = res2.content

    await $vul.update({ Repair: repair, Detail: detail }, id)
    console.log('finished', id)
}

async function comps(start = 1) {
    const max = await $vul.maxId()
    let p = []
    for (let i = start; i <= max; i++) {
        p.push(comp(i))
        if (p.length === 100 || i === max) {
            await Promise.all(p)
            p = []
        }
    }
}

// 递归遍历文件夹并读取Solidity文件内容
function readDirectory(directoryPath, dataset) {
    const files = fs.readdirSync(directoryPath)
    const dir = path.basename(directoryPath) // 获取文件夹名称

    for (const file of files) {
        const filePath = path.join(directoryPath, file)
        const fileStat = fs.statSync(filePath)

        if (fileStat.isDirectory()) readDirectory(filePath, dataset)
        else if (file.endsWith('.sol')) {
            // 如果是Solidity文件，读取内容并添加到数据集
            const content = fs.readFileSync(filePath, 'utf-8')
            dataset.push({ dir, content, file })
        }
    }
}

if (process.argv[1].includes('src/vulnerability')) {
    if (process.argv[2] == 'insert') insert()
    if (process.argv[2] == 'label') label()
    if (process.argv[2] == 'comp') comps(process.argv[3])
}
